---

title: callbacks.mixup
keywords: fastai
sidebar: home_sidebar

summary: "Implementation of mixup"
---
<!--


#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: docs_src/callbacks.mixup.ipynb
# instructions: https://docs.fast.ai/gen_doc_main.html

-->

<div class="container" id="notebook-container">
    
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Mixup-data-augmentation">Mixup data augmentation<a class="anchor-link" href="#Mixup-data-augmentation">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="What-is-mixup?">What is mixup?<a class="anchor-link" href="#What-is-mixup?">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This module contains the implementation of a data augmentation technique called <a href="https://arxiv.org/abs/1710.09412">mixup</a>. It is extremely efficient at regularizing models in computer vision (we used it to get our time to train CIFAR10 to 94% on one GPU to 6 minutes).</p>
<p>As the name kind of suggests, the authors of the mixup article propose training the model on mixes of the training set images. For example, suppose we’re training on CIFAR10.  Instead of feeding the model the raw images, we take two images (not necessarily from the same class) and make a linear combination of them: in terms of tensors, we have:</p>
<p><code>new_image = t * image1 + (1-t) * image2</code></p>
<p>where t is a float between 0 and 1. The target we assign to that new image is the same combination of the original targets:</p>
<p><code>new_target = t * target1 + (1-t) * target2</code></p>
<p>assuming the targets are one-hot encoded (which isn’t the case in PyTorch usually). And it's as simple as that.</p>
<p><img src="imgs/mixup.png" alt="mixup"></p>
<p>Dog or cat? The right answer here is 70% dog and 30% cat!</p>
<p>As the picture above shows, it’s a bit hard for the human eye to make sense of images obtained in this way (although we do see the shapes of a dog and a cat). However, it somehow makes a lot of sense to the model, which trains more efficiently. One important side note is that when training with mixup, the final loss (training or validation) will be higher than when training without it, even when the accuracy is far better: a model trained like this will make predictions that are a bit less confident.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Basic-Training">Basic Training<a class="anchor-link" href="#Basic-Training">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To test this method, we first create a <a href="/layers.html#simple_cnn"><code>simple_cnn</code></a> and train it like we did with <a href="/basic_train.html#basic_train"><code>basic_train</code></a> so we can compare its results with a network trained with mixup.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">path</span> <span class="o">=</span> <span class="n">untar_data</span><span class="p">(</span><span class="n">URLs</span><span class="o">.</span><span class="n">MNIST_SAMPLE</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">ImageDataBunch</span><span class="o">.</span><span class="n">from_folder</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">simple_cnn</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">learn</span> <span class="o">=</span> <span class="n">Learner</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="n">accuracy</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">learn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea ">
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: left;">
      <th>epoch</th>
      <th>train_loss</th>
      <th>valid_loss</th>
      <th>accuracy</th>
      <th>time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0.111498</td>
      <td>0.094612</td>
      <td>0.965653</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>2</td>
      <td>0.079887</td>
      <td>0.064684</td>
      <td>0.975466</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>3</td>
      <td>0.053950</td>
      <td>0.042022</td>
      <td>0.985280</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>4</td>
      <td>0.043062</td>
      <td>0.035917</td>
      <td>0.986752</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>5</td>
      <td>0.030692</td>
      <td>0.025291</td>
      <td>0.989205</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>6</td>
      <td>0.027065</td>
      <td>0.024845</td>
      <td>0.987733</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>7</td>
      <td>0.031135</td>
      <td>0.020047</td>
      <td>0.990186</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>8</td>
      <td>0.025115</td>
      <td>0.025447</td>
      <td>0.988714</td>
      <td>00:02</td>
    </tr>
  </tbody>
</table>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Mixup-implementation-in-the-library">Mixup implementation in the library<a class="anchor-link" href="#Mixup-implementation-in-the-library">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In the original article, the authors suggest four things:</p>

<pre><code>1. Create two separate dataloaders, and draw a batch from each at every iteration to mix them up
2. Draw a value for t following a beta distribution with a parameter alpha (0.4 is suggested in their article)
3. Mix up the two batches with the same value t
4. Use one-hot encoded targets

</code></pre>
<p>This module's implementation is based on these suggestions, and modified where experimental results suggested changes that would improve performance.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The authors suggest using the beta distribution with parameters alpha=0.4. (In general, the beta distribution has two parameters, but in this case they're going to be equal.)  Why do they suggest this? Well, with the parameters they suggest, the beta distribution looks like this:</p>
<p><img src="imgs/betadist-mixup.png" alt="betadist"></p>
<p>meaning that there's a very high probability of picking values close to 0 or 1 (in which case the mixed up image is mostly from only one category) and then a somewhat constant, much smaller probability of picking something in the middle (notice that 0.33 is nearly as likely as 0.5, for instance).</p>
<p>While this works very well, it’s not the fastest way, and this is the first suggestion we adjust. The unnecessary slowdown with this approach comes from drawing two different batches at every iteration, which means loading twice the number of images and additionally applying any other data augmentation functions to them. To avoid this, we apply mixup on a batch with a shuffled version of itself: this way, the images mixed up are still different.</p>
<p>Using the same value of <code>t</code> for the whole batch is another suggestion we modify. In our experiments, we noticed that the model trained faster if we drew a different <code>t</code> for every image in the batch. (Both options got to the same result in terms of accuracy, it’s just that one arrived there more slowly.)</p>
<p>Finally, notice that with this strategy we might create duplicate images: let’s say we are mixing <code>image0</code> with <code>image1</code> and <code>image1</code> with <code>image0</code>, and that we draw <code>t=0.1</code> for the first mix and <code>t=0.9</code> for the second. Then</p>
<p><code>image0 * 0.1 + shuffle0 * (1-0.1) = image0 * 0.1 + image1 * 0.9</code></p>
<p>and</p>
<p><code>image1 * 0.9 + shuffle1 * (1-0.9) = image1 * 0.9 + image0 * 0.1</code></p>
<p>will be the same. Of course we have to be a bit unlucky for this to happen, but in practice, we saw a drop in accuracy when we didn't remove duplicates. To avoid this, the trick is to replace the vector of <code>t</code> we drew with:</p>
<p><code>t = max(t, 1-t)</code></p>
<p>The beta distribution with the two parameters equal is symmetric in any case, and this way we ensure that the largest coefficient is always near the first image (the non-shuffled batch).</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Adding-mixup-to-the-mix">Adding mixup to the mix<a class="anchor-link" href="#Adding-mixup-to-the-mix">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We now add <a href="/callbacks.mixup.html#MixUpCallback"><code>MixUpCallback</code></a> to our Learner so that it modifies our input and target accordingly. The <a href="/train.html#mixup"><code>mixup</code></a> function does this for us behind the scenes, along with a few other tweaks described below:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">simple_cnn</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">learner</span> <span class="o">=</span> <span class="n">Learner</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="n">accuracy</span><span class="p">])</span><span class="o">.</span><span class="n">mixup</span><span class="p">()</span>
<span class="n">learner</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea ">
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: left;">
      <th>epoch</th>
      <th>train_loss</th>
      <th>valid_loss</th>
      <th>accuracy</th>
      <th>time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0.358743</td>
      <td>0.156058</td>
      <td>0.961236</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>2</td>
      <td>0.334059</td>
      <td>0.124648</td>
      <td>0.982336</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>3</td>
      <td>0.321510</td>
      <td>0.105825</td>
      <td>0.987242</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>4</td>
      <td>0.314596</td>
      <td>0.099804</td>
      <td>0.988714</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>5</td>
      <td>0.314716</td>
      <td>0.094472</td>
      <td>0.989205</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>6</td>
      <td>0.309679</td>
      <td>0.095133</td>
      <td>0.989696</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>7</td>
      <td>0.314474</td>
      <td>0.086767</td>
      <td>0.990186</td>
      <td>00:02</td>
    </tr>
    <tr>
      <td>8</td>
      <td>0.309931</td>
      <td>0.095609</td>
      <td>0.990186</td>
      <td>00:02</td>
    </tr>
  </tbody>
</table>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Training with mixup improves the best accuracy. Note that the validation loss is higher than without mixup, because the model makes less confident predictions: without mixup, most predictions are very close to 0. or 1. (in terms of probability) whereas the model with mixup makes predictions that are more nuanced. Before using mixup, make sure you know whether it's more important to optimize lower loss or better accuracy.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="MixUpCallback" class="doc_header"><code>class</code> <code>MixUpCallback</code><a href="https://github.com/fastai/fastai/blob/master/fastai/callbacks/mixup.py#L8" class="source_link" style="float:right">[source]</a><a class="source_link" data-toggle="collapse" data-target="#MixUpCallback-pytest" style="float:right; padding-right:10px">[test]</a></h2><blockquote><p><code>MixUpCallback</code>(<strong><code>learn</code></strong>:<a href="/basic_train.html#Learner"><code>Learner</code></a>, <strong><code>alpha</code></strong>:<code>float</code>=<strong><em><code>0.4</code></em></strong>, <strong><code>stack_x</code></strong>:<code>bool</code>=<strong><em><code>False</code></em></strong>, <strong><code>stack_y</code></strong>:<code>bool</code>=<strong><em><code>True</code></em></strong>) :: <a href="/basic_train.html#LearnerCallback"><code>LearnerCallback</code></a></p>
</blockquote>
<div class="collapse" id="MixUpCallback-pytest"><div class="card card-body pytest_card"><a type="button" data-toggle="collapse" data-target="#MixUpCallback-pytest" class="close" aria-label="Close"><span aria-hidden="true">&times;</span></a><p>No tests found for <code>MixUpCallback</code>. To contribute a test please refer to <a href="/dev/test.html">this guide</a> and <a href="https://forums.fast.ai/t/improving-expanding-functional-tests/32929">this discussion</a>.</p></div></div><p>Callback that creates the mixed-up input and target.</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Create a <a href="/callback.html#Callback"><code>Callback</code></a> for mixup on <code>learn</code> with a parameter <code>alpha</code> for the beta distribution. <code>stack_x</code> and <code>stack_y</code> determine whether we stack our inputs/targets with the vector lambda drawn or do the linear combination. (In general, we stack the inputs or outputs when they correspond to categories or classes and do the linear combination otherwise.)</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Callback-methods">Callback methods<a class="anchor-link" href="#Callback-methods">&#182;</a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You don't call these yourself - they're called by fastai's <a href="/callback.html#Callback"><code>Callback</code></a> system automatically to enable the class's functionality.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="MixUpCallback.on_batch_begin" class="doc_header"><code>on_batch_begin</code><a href="https://github.com/fastai/fastai/blob/master/fastai/callbacks/mixup.py#L17" class="source_link" style="float:right">[source]</a><a class="source_link" data-toggle="collapse" data-target="#MixUpCallback-on_batch_begin-pytest" style="float:right; padding-right:10px">[test]</a></h4><blockquote><p><code>on_batch_begin</code>(<strong><code>last_input</code></strong>, <strong><code>last_target</code></strong>, <strong><code>train</code></strong>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<div class="collapse" id="MixUpCallback-on_batch_begin-pytest"><div class="card card-body pytest_card"><a type="button" data-toggle="collapse" data-target="#MixUpCallback-on_batch_begin-pytest" class="close" aria-label="Close"><span aria-hidden="true">&times;</span></a><p>No tests found for <code>on_batch_begin</code>. To contribute a test please refer to <a href="/dev/test.html">this guide</a> and <a href="https://forums.fast.ai/t/improving-expanding-functional-tests/32929">this discussion</a>.</p></div></div><p>Applies mixup to <code>last_input</code> and <code>last_target</code> if <code>train</code>.</p>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Draws a vector of lambda following a beta distribution with <code>self.alpha</code> and operates the mixup on <code>last_input</code> and <code>last_target</code> according to <code>self.stack_x</code> and <code>self.stack_y</code>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Dealing-with-the-loss">Dealing with the loss<a class="anchor-link" href="#Dealing-with-the-loss">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We often have to modify the loss so that it is compatible with mixup. PyTorch was very careful to avoid one-hot encoding targets when possible, so it seems a bit of a drag to undo this. Fortunately for us, if the loss is a classic <a href="https://pytorch.org/docs/stable/nn.html#torch.nn.functional.cross_entropy">cross-entropy</a>, we have</p>
<p><code>loss(output, new_target) = t * loss(output, target1) + (1-t) * loss(output, target2)</code></p>
<p>so we don’t one-hot encode anything and instead just compute those two losses and find the linear combination.</p>
<p>The following class is used to adapt the loss for mixup. Note that the <a href="/train.html#mixup"><code>mixup</code></a> function will use it to change the <code>Learner.loss_func</code> if necessary.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h3 id="MixUpLoss" class="doc_header"><code>class</code> <code>MixUpLoss</code><a href="https://github.com/fastai/fastai/blob/master/fastai/callbacks/mixup.py#L42" class="source_link" style="float:right">[source]</a><a class="source_link" data-toggle="collapse" data-target="#MixUpLoss-pytest" style="float:right; padding-right:10px">[test]</a></h3><blockquote><p><code>MixUpLoss</code>(<strong><code>crit</code></strong>, <strong><code>reduction</code></strong>=<strong><em><code>'mean'</code></em></strong>) :: <a href="/core.html#PrePostInitMeta"><code>PrePostInitMeta</code></a> :: <a href="/torch_core.html#Module"><code>Module</code></a></p>
</blockquote>
<div class="collapse" id="MixUpLoss-pytest"><div class="card card-body pytest_card"><a type="button" data-toggle="collapse" data-target="#MixUpLoss-pytest" class="close" aria-label="Close"><span aria-hidden="true">&times;</span></a><p>No tests found for <code>MixUpLoss</code>. To contribute a test please refer to <a href="/dev/test.html">this guide</a> and <a href="https://forums.fast.ai/t/improving-expanding-functional-tests/32929">this discussion</a>.</p></div></div><p>Adapt the loss function <code>crit</code> to go with mixup.</p>

</div>

</div>

</div>
</div>

</div>
</div>
 

