# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/13b_metrics.ipynb (unless otherwise specified).

__all__ = ['func_to_metric', 'skm_to_fastai', 'optim_metric', 'Accuracy', 'ErrorRate', 'TopKAccuracy', 'APScoreBinary',
           'BalancedAccuracy', 'BrierScore', 'CohenKappa', 'F1Score', 'FBeta', 'HammingLoss', 'Jaccard', 'Precision',
           'Recall', 'RocAuc', 'RocAucBinary', 'MatthewsCorrCoef', 'AccuracyMulti', 'APScoreMulti', 'BrierScoreMulti',
           'F1ScoreMulti', 'FBetaMulti', 'HammingLossMulti', 'JaccardMulti', 'MatthewsCorrCoefMulti', 'PrecisionMulti',
           'RecallMulti', 'RocAucMulti', 'MSE', 'rmse', 'RMSE', 'MAE', 'MSLE', 'exp_rmspe', 'ExpRMSE',
           'ExplainedVariance', 'R2Score', 'PearsonCorrCoef', 'SpearmanCorrCoef', 'ForegroundAcc', 'Dice', 'DiceMulti',
           'JaccardCoeff', 'CorpusBLEUMetric', 'Perplexity', 'perplexity', 'LossMetric', 'LossMetrics']

# Cell
from .data.all import *
from .optimizer import *
from .learner import *

# Cell
import sklearn.metrics as skm
import scipy.stats as scs

# Cell
@delegates(Metric)
def func_to_metric(func, metric_type, is_class, thresh=None, axis=-1, activation=None, log_metric=None, **kwargs):
    "Convert `func` metric to a fastai metric"

    dim_argmax = axis if is_class and thresh is None else None
    if activation is None:
        activation = ActivationType.Sigmoid if (is_class and thresh is not None) else ActivationType.No

    if metric_type==MetricType.Accum:
        return AccumMetric(func, dim_argmax=dim_argmax, activation=activation,
                           thresh=thresh, log_metric=log_metric, **kwargs)
    elif metric_type==MetricType.Avg:
        return AvgMetric(func, dim_argmax=dim_argmax, activation=activation,
                         thresh=thresh, log_metric=log_metric, **kwargs)
    elif metric_type==MetricType.Smooth:
        if log_metric==LogMetric.Both:
            name = func.func.__name__ if hasattr(func, 'func') else  func.__name__
            raise ValueError(f'Error with {name}: AvgSmoothMetric must be Valid or Train. To run on both, duplicate metric.')
        return AvgSmoothMetric(func, dim_argmax=dim_argmax, activation=activation,
                               thresh=thresh, log_metric=log_metric, **kwargs)
    else:
        name = func.func.__name__ if hasattr(func, 'func') else  func.__name__
        raise ValueError(f"Unsupported `metric_type` {metric_type} for metric {name}.")

# Cell
@delegates(Metric)
def skm_to_fastai(func, is_class=True, thresh=None, axis=-1, activation=None, log_metric=None, **kwargs):
    "Convert `func` from sklearn.metrics to a fastai metric"
    return func_to_metric(func, MetricType.Accum, is_class, thresh, axis, activation,
                          log_metric, to_np=True, invert_arg=True, **kwargs)

# Cell
def optim_metric(f, argname, bounds, tol=0.01, do_neg=True, get_x=False):
    "Replace metric `f` with a version that optimizes argument `argname`"
    def _f(preds, targs):
        def minfunc(x):
            kwargs = {argname:x}
            res = f(preds, targs, **kwargs)
            return -res if do_neg else res
        optres = scipy.optimize.minimize_scalar(minfunc, bounds=bounds, method='bounded',
                                                options={'xatol':0.01})
        fun = -optres.fun if do_neg else optres.fun
        return (fun,optres.x) if get_x else fun
    _f.__name__ = f'opt_{f.__name__}'
    return _f

# Internal Cell
def accuracy(inp, targ, axis=-1):
    "Compute accuracy with `targ` when `pred` is bs * n_classes"
    pred,targ = flatten_check(inp, targ)
    return (pred == targ).float().mean()

# Cell
@delegates(Metric)
def Accuracy(axis=-1, metric_type=MetricType.Avg, log_metric=LogMetric.Valid, **kwargs):
    "Compute accuracy with `targ` when `pred` is bs * n_classes"
    return func_to_metric(accuracy, metric_type, True, axis=axis, log_metric=log_metric, **kwargs)

# Internal Cell
def error_rate(inp, targ, axis=-1):
    "1 - `accuracy`"
    return 1 - accuracy(inp, targ, axis=axis)

# Cell
@delegates(Metric)
def ErrorRate(axis=-1, metric_type=MetricType.Avg, log_metric=LogMetric.Valid, **kwargs):
    "Compute 1 - accuracy with `targ` when `pred` is bs * n_classes"
    return func_to_metric(error_rate, metric_type, True, axis=axis, log_metric=log_metric, **kwargs)

# Internal Cell
def top_k_accuracy(inp, targ, k=5, axis=-1):
    "Computes the Top-k accuracy (`targ` is in the top `k` predictions of `inp`)"
    inp = inp.topk(k=k, dim=axis)[1]
    targ = targ.unsqueeze(dim=axis).expand_as(inp)
    return (inp == targ).sum(dim=-1).float().mean()

# Cell
@delegates(Metric)
def TopKAccuracy(k=5, axis=-1, metric_type=MetricType.Avg, log_metric=LogMetric.Valid, **kwargs):
    "Computes the Top-k accuracy (`targ` is in the top `k` predictions of `inp`)"
    return func_to_metric(partial(top_k_accuracy, k=k, axis=axis), metric_type, False,
                          log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.average_precision_score)
def APScoreBinary(axis=-1, average='macro', pos_label=1, sample_weight=None, log_metric=LogMetric.Valid, **kwargs):
    "Average Precision for single-label binary classification problems"
    return skm_to_fastai(skm.average_precision_score, axis=axis, activation=ActivationType.BinarySoftmax,
                         average=average, pos_label=pos_label, sample_weight=sample_weight, log_metric=log_metric,
                         **kwargs)

# Cell
@delegates(skm.balanced_accuracy_score)
def BalancedAccuracy(axis=-1, sample_weight=None, adjusted=False, log_metric=LogMetric.Valid, **kwargs):
    "Balanced Accuracy for single-label binary classification problems"
    return skm_to_fastai(skm.balanced_accuracy_score, axis=axis,
                         sample_weight=sample_weight, adjusted=adjusted, log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.brier_score_loss)
def BrierScore(axis=-1, sample_weight=None, pos_label=None, log_metric=LogMetric.Valid, **kwargs):
    "Brier score for single-label classification problems"
    return skm_to_fastai(skm.brier_score_loss, axis=axis,
                         sample_weight=sample_weight, pos_label=pos_label, log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.cohen_kappa_score)
def CohenKappa(axis=-1, labels=None, weights=None, sample_weight=None, log_metric=LogMetric.Valid, **kwargs):
    "Cohen kappa for single-label classification problems"
    return skm_to_fastai(skm.cohen_kappa_score, axis=axis, labels=labels, weights=weights,
                         sample_weight=sample_weight, log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.f1_score)
def F1Score(axis=-1, labels=None, pos_label=1, average='binary', sample_weight=None, log_metric=LogMetric.Valid, **kwargs):
    "F1 score for single-label classification problems"
    return skm_to_fastai(skm.f1_score, axis=axis, labels=labels, pos_label=pos_label,
                         average=average, sample_weight=sample_weight, log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.fbeta_score)
def FBeta(beta, axis=-1, labels=None, pos_label=1, average='binary', sample_weight=None,
          log_metric=LogMetric.Valid, **kwargs):
    "FBeta score with `beta` for single-label classification problems"
    return skm_to_fastai(skm.fbeta_score, axis=axis, beta=beta, labels=labels, pos_label=pos_label,
                         average=average, sample_weight=sample_weight, log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.hamming_loss)
def HammingLoss(axis=-1, sample_weight=None, log_metric=LogMetric.Valid, **kwargs):
    "Hamming loss for single-label classification problems"
    return skm_to_fastai(skm.hamming_loss, axis=axis,
                         sample_weight=sample_weight, log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.jaccard_score)
def Jaccard(axis=-1, labels=None, pos_label=1, average='binary', sample_weight=None,
            log_metric=LogMetric.Valid, **kwargs):
    "Jaccard score for single-label classification problems"
    return skm_to_fastai(skm.jaccard_score, axis=axis, labels=labels, pos_label=pos_label,
                         average=average, sample_weight=sample_weight, log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.precision_score)
def Precision(axis=-1, labels=None, pos_label=1, average='binary', sample_weight=None,
              log_metric=LogMetric.Valid, **kwargs):
    "Precision for single-label classification problems"
    return skm_to_fastai(skm.precision_score, axis=axis, labels=labels, pos_label=pos_label,
                         average=average, sample_weight=sample_weight, log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.recall_score)
def Recall(axis=-1, labels=None, pos_label=1, average='binary', sample_weight=None,
           log_metric=LogMetric.Valid, **kwargs):
    "Recall for single-label classification problems"
    return skm_to_fastai(skm.recall_score, axis=axis, labels=labels, pos_label=pos_label,
                         average=average, sample_weight=sample_weight, log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.roc_auc_score)
def RocAuc(axis=-1, average='macro', sample_weight=None, max_fpr=None, multi_class='ovr',
           log_metric=LogMetric.Valid, **kwargs):
    "Area Under the Receiver Operating Characteristic Curve for single-label multiclass classification problems"
    assert multi_class in ['ovr', 'ovo']
    return skm_to_fastai(skm.roc_auc_score, axis=axis, activation=ActivationType.Softmax, flatten=False,
                         average=average, sample_weight=sample_weight, max_fpr=max_fpr, multi_class=multi_class,
                         log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.roc_auc_score)
def RocAucBinary(axis=-1, average='macro', sample_weight=None, max_fpr=None, multi_class='raise',
                 log_metric=LogMetric.Valid, **kwargs):
    "Area Under the Receiver Operating Characteristic Curve for single-label binary classification problems"
    return skm_to_fastai(skm.roc_auc_score, axis=axis, activation=ActivationType.BinarySoftmax,
                         average=average, sample_weight=sample_weight, max_fpr=max_fpr, multi_class=multi_class,
                         log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.matthews_corrcoef)
def MatthewsCorrCoef(sample_weight=None, log_metric=LogMetric.Valid, **kwargs):
    "Matthews correlation coefficient for single-label classification problems"
    return skm_to_fastai(skm.matthews_corrcoef, sample_weight=sample_weight, log_metric=log_metric, **kwargs)

# Internal Cell
def accuracy_multi(inp, targ):
    "Compute accuracy when `inp` and `targ` are the same size."
    inp,targ = flatten_check(inp,targ)
    return (inp==targ.bool()).float().mean()

# Cell
@delegates(Metric)
def AccuracyMulti(thresh=0.5, sigmoid=True, metric_type=MetricType.Avg, log_metric=LogMetric.Valid, **kwargs):
    "Compute accuracy when `inp` and `targ` are the same size."
    activation = ActivationType.Sigmoid if sigmoid else ActivationType.No
    return func_to_metric(accuracy_multi, metric_type, False, thresh=thresh, activation=activation,
                          log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.average_precision_score)
def APScoreMulti(sigmoid=True, average='macro', pos_label=1, sample_weight=None,
                 log_metric=LogMetric.Valid, **kwargs):
    "Average Precision for multi-label classification problems"
    activation = ActivationType.Sigmoid if sigmoid else ActivationType.No
    return skm_to_fastai(skm.average_precision_score, activation=activation, flatten=False,
                         average=average, pos_label=pos_label, sample_weight=sample_weight,
                         log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.brier_score_loss)
def BrierScoreMulti(thresh=0.5, sigmoid=True, sample_weight=None, pos_label=None,
                    log_metric=LogMetric.Valid, **kwargs):
    "Brier score for multi-label classification problems"
    activation = ActivationType.Sigmoid if sigmoid else ActivationType.No
    return skm_to_fastai(skm.brier_score_loss, thresh=thresh, activation=activation, flatten=False,
                         sample_weight=sample_weight, pos_label=pos_label, log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.f1_score)
def F1ScoreMulti(thresh=0.5, sigmoid=True, labels=None, pos_label=1, average='macro', sample_weight=None,
                 log_metric=LogMetric.Valid, **kwargs):
    "F1 score for multi-label classification problems"
    activation = ActivationType.Sigmoid if sigmoid else ActivationType.No
    return skm_to_fastai(skm.f1_score, thresh=thresh, activation=activation, flatten=False,
                         labels=labels, pos_label=pos_label, average=average, sample_weight=sample_weight,
                         log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.fbeta_score)
def FBetaMulti(beta, thresh=0.5, sigmoid=True, labels=None, pos_label=1, average='macro', sample_weight=None,
               log_metric=LogMetric.Valid, **kwargs):
    "FBeta score with `beta` for multi-label classification problems"
    activation = ActivationType.Sigmoid if sigmoid else ActivationType.No
    return skm_to_fastai(skm.fbeta_score, thresh=thresh, activation=activation, flatten=False,
                beta=beta, labels=labels, pos_label=pos_label, average=average, sample_weight=sample_weight,
                log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.hamming_loss)
def HammingLossMulti(thresh=0.5, sigmoid=True, labels=None, sample_weight=None,
                     log_metric=LogMetric.Valid, **kwargs):
    "Hamming loss for multi-label classification problems"
    activation = ActivationType.Sigmoid if sigmoid else ActivationType.No
    return skm_to_fastai(skm.hamming_loss, thresh=thresh, activation=activation, flatten=False,
                         sample_weight=sample_weight, log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.jaccard_score)
def JaccardMulti(thresh=0.5, sigmoid=True, labels=None, pos_label=1, average='macro', sample_weight=None,
                 log_metric=LogMetric.Valid, **kwargs):
    "Jaccard score for multi-label classification problems"
    activation = ActivationType.Sigmoid if sigmoid else ActivationType.No
    return skm_to_fastai(skm.jaccard_score, thresh=thresh, activation=activation, flatten=False,
                         labels=labels, pos_label=pos_label, average=average, sample_weight=sample_weight,
                         log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.matthews_corrcoef)
def MatthewsCorrCoefMulti(thresh=0.5, sigmoid=True, sample_weight=None, log_metric=LogMetric.Valid, **kwargs):
    "Matthews correlation coefficient for multi-label classification problems"
    activation = ActivationType.Sigmoid if sigmoid else ActivationType.No
    return skm_to_fastai(skm.matthews_corrcoef, thresh=thresh, activation=activation, flatten=False,
                         sample_weight=sample_weight, log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.precision_score)
def PrecisionMulti(thresh=0.5, sigmoid=True, labels=None, pos_label=1, average='macro', sample_weight=None,
                   log_metric=LogMetric.Valid, **kwargs):
    "Precision for multi-label classification problems"
    activation = ActivationType.Sigmoid if sigmoid else ActivationType.No
    return skm_to_fastai(skm.precision_score, thresh=thresh, activation=activation, flatten=False,
                         labels=labels, pos_label=pos_label, average=average, sample_weight=sample_weight,
                         log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.recall_score)
def RecallMulti(thresh=0.5, sigmoid=True, labels=None, pos_label=1, average='macro', sample_weight=None,
                log_metric=LogMetric.Valid, **kwargs):
    "Recall for multi-label classification problems"
    activation = ActivationType.Sigmoid if sigmoid else ActivationType.No
    return skm_to_fastai(skm.recall_score, thresh=thresh, activation=activation, flatten=False,
                         labels=labels, pos_label=pos_label, average=average, sample_weight=sample_weight,
                         log_metric=log_metric, **kwargs)

# Cell
@delegates(skm.roc_auc_score)
def RocAucMulti(sigmoid=True, average='macro', sample_weight=None, max_fpr=None, log_metric=LogMetric.Valid, **kwargs):
    "Area Under the Receiver Operating Characteristic Curve for multi-label binary classification problems"
    activation = ActivationType.Sigmoid if sigmoid else ActivationType.No
    return skm_to_fastai(skm.roc_auc_score, activation=activation, flatten=False,
                         average=average, sample_weight=sample_weight, max_fpr=max_fpr, log_metric=log_metric, **kwargs)

# Internal Cell
def mse(inp,targ):
    "Mean squared error between `inp` and `targ`."
    return F.mse_loss(*flatten_check(inp,targ))

# Cell
@delegates(Metric)
def MSE(metric_type=MetricType.Avg, log_metric=LogMetric.Valid, **kwargs):
    "Mean squared error between `inp` and `targ`."
    return func_to_metric(mse, metric_type, False, log_metric=log_metric, **kwargs)

# Cell
def rmse(inp, targ):
    return torch.sqrt(F.mse_loss(inp, targ))

# Cell
@delegates(Metric)
def RMSE(log_metric=LogMetric.Valid, **kwargs):
    "Mean squared error between `inp` and `targ`."
    return func_to_metric(rmse, MetricType.Accum, False, log_metric=log_metric, **kwargs)

# Internal Cell
def mae(inp,targ):
    "Mean absolute error between `inp` and `targ`."
    inp,targ = flatten_check(inp,targ)
    return torch.abs(inp - targ).mean()

# Cell
@delegates(Metric)
def MAE(metric_type=MetricType.Avg, log_metric=LogMetric.Valid, **kwargs):
    "Mean absolute error between `inp` and `targ`."
    return func_to_metric(mae, metric_type, False, log_metric=log_metric, **kwargs)

# Internal Cell
def msle(inp, targ):
    "Mean squared logarithmic error between `inp` and `targ`."
    inp,targ = flatten_check(inp,targ)
    return F.mse_loss(torch.log(1 + inp), torch.log(1 + targ))

# Cell
@delegates(Metric)
def MSLE(metric_type=MetricType.Avg, log_metric=LogMetric.Valid, **kwargs):
    "Mean squared logarithmic error between `inp` and `targ`."
    return func_to_metric(msle, metric_type, False, log_metric=log_metric, **kwargs)

# Cell
def exp_rmspe(inp,targ):
    inp,targ = torch.exp(inp),torch.exp(targ)
    return torch.sqrt(((targ - inp)/targ).pow(2).mean())

# Cell
@delegates(Metric)
def ExpRMSE(log_metric=LogMetric.Valid, **kwargs):
    "Root mean square percentage error of the exponential of  predictions and targets"
    return func_to_metric(exp_rmspe, MetricType.Accum, False, log_metric=log_metric, **kwargs)

# Cell
def ExplainedVariance(sample_weight=None, log_metric=LogMetric.Valid, **kwargs):
    "Explained variance between predictions and targets"
    return skm_to_fastai(skm.explained_variance_score, is_class=False,
                         sample_weight=sample_weight, log_metric=log_metric, **kwargs)

# Cell
def R2Score(sample_weight=None, log_metric=LogMetric.Valid, **kwargs):
    "R2 score between predictions and targets"
    return skm_to_fastai(skm.r2_score, is_class=False, sample_weight=sample_weight,
                         log_metric=log_metric, **kwargs)

# Cell
@delegates(AccumMetric)
def PearsonCorrCoef(dim_argmax=None, log_metric=LogMetric.Valid, **kwargs):
    "Pearson correlation coefficient for regression problem"
    def pearsonr(x,y): return scs.pearsonr(x,y)[0]
    return AccumMetric(pearsonr, invert_arg=False, dim_argmax=dim_argmax,
                       log_metric=log_metric, **kwargs)

# Cell
@delegates(AccumMetric)
def SpearmanCorrCoef(dim_argmax=None, axis=0, nan_policy='propagate', log_metric=LogMetric.Valid, **kwargs):
    "Spearman correlation coefficient for regression problem"
    def spearmanr(a,b=None,**kwargs): return scs.spearmanr(a,b,**kwargs)[0]
    return AccumMetric(partial(spearmanr, axis=axis, nan_policy=nan_policy),
                       invert_arg=False, dim_argmax=dim_argmax, log_metric=log_metric, **kwargs)

# Internal Cell
def foreground_acc(inp, targ, bkg_idx=0, axis=1):
    "Computes non-background accuracy for multiclass segmentation"
    targ = cast(targ.squeeze(1), TensorBase)
    mask = targ != bkg_idx
    return (inp[mask]==targ[mask]).float().mean()

# Cell
@delegates(Metric)
def ForegroundAcc(bkg_idx=0, axis=1, metric_type=MetricType.Avg, log_metric=LogMetric.Valid, **kwargs):
    "Computes non-background accuracy for multiclass segmentation"
    return func_to_metric(foreground_acc, metric_type, True, bkg_idx=bkg_idx, axis=axis,
                          log_metric=log_metric, **kwargs)

# Cell
@delegates(Metric)
class Dice(Metric):
    "Dice coefficient metric for binary target in segmentation"
    def __init__(self, axis=1, log_metric=LogMetric.Valid, **kwargs):
        super().__init__(dim_argmax=axis, log_metric=log_metric, **kwargs)
    def reset(self): self.inter,self.union = 0,0
    def accumulate(self, learn):
        super().accumulate(learn)
        self.pred,self.targ = flatten_check(self.pred, self.targ)
        self.inter += (self.pred*self.targ).float().sum().item()
        self.union += (self.pred+self.targ).float().sum().item()

    @property
    def value(self): return 2. * self.inter/self.union if self.union > 0 else None

# Cell
@delegates(Metric)
class DiceMulti(Metric):
    "Averaged Dice metric (Macro F1) for multiclass target in segmentation"
    def __init__(self, axis=1, log_metric=LogMetric.Valid, **kwargs):
        super().__init__(dim_argmax=axis, log_metric=log_metric, **kwargs)
    def reset(self): self.inter,self.union = {},{}
    def accumulate(self, learn):
        super().accumulate(learn)
        self.pred,self.targ = flatten_check(self.pred, self.targ)
        for c in range(learn.pred.shape[self.dim_argmax]):
            p = torch.where(self.pred == c, 1, 0)
            t = torch.where(self.targ == c, 1, 0)
            c_inter = (p*t).float().sum().item()
            c_union = (p+t).float().sum().item()
            if c in self.inter:
                self.inter[c] += c_inter
                self.union[c] += c_union
            else:
                self.inter[c] = c_inter
                self.union[c] = c_union

    @property
    def value(self):
        binary_dice_scores = np.array([])
        for c in self.inter:
            binary_dice_scores = np.append(binary_dice_scores, 2.*self.inter[c]/self.union[c] if self.union[c] > 0 else np.nan)
        return np.nanmean(binary_dice_scores)

# Cell
@delegates(Metric)
class JaccardCoeff(Dice):
    "Implementation of the Jaccard coefficient that is lighter in RAM"
    @property
    def value(self): return self.inter/(self.union-self.inter) if self.union > 0 else None

# Cell
@delegates(Metric)
class CorpusBLEUMetric(Metric):
    "BLEU Metric calculated over the validation corpus"
    def __init__(self, vocab_sz=5000, axis=-1, log_metric=LogMetric.Valid, name='CorpusBLEU', **kwargs):
        super().__init__(log_metric=log_metric, name=name, **kwargs)
        self.axis, self.vocab_sz = axis, vocab_sz
        self.pred_len,self.targ_len,self.samp_idx,self.corrects,self.counts, = 0,0,0,[0]*4,[0]*4

    def reset(self):
        self.pred_len,self.targ_len,self.corrects,self.counts = 0,0,[0]*4,[0]*4

    class NGram():
        def __init__(self, ngram, max_n=5000): self.ngram,self.max_n = ngram,max_n
        def __eq__(self, other):
            if len(self.ngram) != len(other.ngram): return False
            return np.all(np.array(self.ngram) == np.array(other.ngram))
        def __hash__(self): return int(sum([o * self.max_n**i for i,o in enumerate(self.ngram)]))

    def get_grams(self, x, n, max_n=5000):
        return x if n==1 else [self.NGram(x[i:i+n], max_n=max_n) for i in range(len(x)-n+1)]

    def get_correct_ngrams(self, pred, targ, n, max_n=5000):
        pred_grams,targ_grams = self.get_grams(pred, n, max_n=max_n),self.get_grams(targ, n, max_n=max_n)
        pred_cnt,targ_cnt = Counter(pred_grams),Counter(targ_grams)
        return sum([min(c, targ_cnt[g]) for g,c in pred_cnt.items()]),len(pred_grams)

    def accumulate(self, learn):
        if learn.training: return None
        else:
            last_output = learn.pred.argmax(dim=self.axis)
            last_target = learn.y
            for pred,targ in zip(last_output.cpu().numpy(),last_target.cpu().numpy()):
                self.pred_len += len(pred)
                self.targ_len += len(targ)
                smooth_mteval = 1
                for i in range(4):
                    c,t = self.get_correct_ngrams(pred, targ, i+1, max_n=self.vocab_sz)
                    if c == 0:
                        smooth_mteval *= 2
                        c = 1 / smooth_mteval    # exp smoothing, method 3 from http://acl2014.org/acl2014/W14-33/pdf/W14-3346.pdf
                    self.corrects[i] += c
                    self.counts[i]   += t

    @property
    def value(self):
        if self.counts == 0: return None
        elif max(self.corrects) == 0: return 0.0
        else:
            precs = [c/t for c,t in zip(self.corrects,self.counts)]
            len_penalty = math.exp(1 - self.targ_len/self.pred_len) if self.pred_len < self.targ_len else 1
            return len_penalty * ((precs[0]*precs[1]*precs[2]*precs[3]) ** 0.25)

# Cell
class Perplexity(AvgLoss):
    "Perplexity (exponential of cross-entropy loss) for Language Models"
    @property
    def value(self): return torch.exp(self.total/self.count) if self.count != 0 else None
    @property
    def name(self):  return "perplexity"

perplexity = Perplexity()

# Cell
class LossMetric(AvgMetric):
    "Create a metric from `loss_func.attr` named `nm`"
    def __init__(self, attr, nm=None, log_metric=LogMetric.Valid, **kwargs):
        super().__init__(noop, log_metric=log_metric, **kwargs)
        store_attr('attr,nm')
    def accumulate(self, learn):
        bs = find_bs(learn.yb)
        self.total += learn.to_detach(getattr(learn.loss_func, self.attr, 0))*bs
        self.count += bs

    @property
    def name(self): return self.attr if self.nm is None else self.nm

# Cell
def LossMetrics(attrs, nms=None):
    "List of `LossMetric` for each of `attrs` and `nms`"
    if isinstance(attrs, str): attrs = attrs.split(',')
    nms = attrs if nms is None else nms.split(',') if isinstance(nms, str) else nms
    return [LossMetric(a, n) for a,n in zip(attrs,nms)]